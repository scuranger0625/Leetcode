from typing import List

class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        # =========================
        # 【特殊情況處理】
        # =========================
        # 題目要求的是「乘積 < k」
        # 但 nums 裡的數字最小是 1
        # 所以任何子陣列的乘積都 >= 1
        # 如果 k <= 1，就不可能有任何合法子陣列
        if k <= 1:
            return 0

        # n = 陣列長度
        n = len(nums)

        # count 用來記錄「符合條件的子陣列數量」
        count = 0

        # =========================
        # 【外層迴圈：左端點 i】
        # =========================
        # i 代表「子陣列的起點」
        # 我們要嘗試每一個位置當作子陣列的左邊界
        for i in range(n):

            # product 代表「目前子陣列 nums[i..j] 的乘積」
            # 一開始什麼都還沒選
            # 乘法的起始值一定是 1（不是 0）
            product = 1

            # =========================
            # 【內層迴圈：右端點 j】
            # =========================
            # j 從 i 開始往右延伸
            # 代表子陣列一定是「連續的」
            for j in range(i, n):

                # 把 nums[j] 乘進目前的子陣列乘積
                # 這一行等價於：
                # product = nums[i] * nums[i+1] * ... * nums[j]
                product *= nums[j]

                # =========================
                # 【檢查條件】
                # =========================
                # 如果目前這段子陣列的乘積 < k
                # 代表這是一個「合法解」
                if product < k:
                    # 題目要的是「數量」
                    # 所以每找到一個合法子陣列，就 +1
                    count += 1
                else:
                    # =========================
                    # 【為什麼可以 break？】
                    # =========================
                    # 因為 nums 裡的數字全部 >= 1
                    # 一旦乘積 >= k
                    # 再往右乘只會更大，不可能再 < k
                    # 所以這個 i 當左端點的情況可以直接結束
                    break

        # 回傳所有「乘積 < k 的連續子陣列」數量
        return count
